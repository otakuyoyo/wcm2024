{"pages":[{"title":"About","text":"cmsimde 內容管理系統 倉儲: https://github.com/otakuyoyo/wcm2024\"> 網站: https://mde.tw/cmsimde_site/ 簡報: https://mde.tw/cmsimde_site/reveal 網誌: https://otakuyoyo.github.io/wcm2024/blog","tags":"misc","url":"./pages/about/"},{"title":"w3課程","text":"git 的新增、提交與推送指令: git add . git commit -m \"說明字串\" git push 使用 git add . 表示要認列所進行的全部改版內容, git commit -m 執行之前, 若在近端使用, 必須先行設定 git config, 將 home_ipv6 目錄下的 .gitconfig 中明確列出改版者的身分, 其中包括: git config --global user.name \"提交者的 github 帳號名稱\" git config --global user.email \"提交者在 github 所登錄的 email address\" 使用者也可以利用 git version 查詢目前所使用的 git 版本. git status 通常用來查核目前近端的改版狀況, 例如: 是否與遠端倉儲同步, 或者遠端倉儲已經有了新版本. 若遠端倉儲已經有新的版本, 則在 git push 之前, 必須設法取下遠端資料進行合併後, 才能再提交新的版本並推送到遠端. git pull = git fetch + git merge 由於要將各組員的 wcm2024 設定為各分組倉儲的子模組, 因此必須利用 git submodule add 以各組員的學號作為子目錄名稱, 利用下列指令, 將組員倉儲新增為分組倉儲的子模組: git submodule add 倉儲網址 子目錄 若只要取下倉儲的主要內容, 可以使用下列指令: git clone 倉儲網址_協定.git 指定目錄與否 若要取下帶有子模組的倉儲, 且可能該子模組還有設定其他子模組, 則必須要加上 --recurse-submodules: git clone --recurse-submodules 倉儲網址_協定.git 指定目錄與否","tags":"w3","url":"./w3.html"},{"title":"w4課程","text":"有關建立網站 這裡所謂的網站指的是 Web site, 也就是 WWW (World Wide Web) 伺服器 (Server)端的超文件 (Hypertext), 且此超文件包含 css 與 Javascript 資料, 用來定義使用者利用瀏覽器連線時所得到的資料內容. 網際內容管理的網際指的並非網際網路的 Internet, 而是指 Web-based, 也就是針對網頁瀏覽器檢視的內容加以管理, 而這些內容除了具備各種不同格式的文字外, 還包括靜態圖片與動態的影音多媒體. 因為希望所管理的網站內容, 從無到有的過程留下改版歷程, 因此使用分散式版次管理系統進行網頁的配置, 也就是利用 Github 所提供的 Pages 功能來建立網頁. 又因為直接編輯帶有各種標註符號的超文件過程較為繁瑣, 因此利用 Python 與 Javascript 編寫了一套網頁編輯系統, 也就是 cmsimde 套件, 可以在 Python 與特定模組的環境中啟動, 也就是所謂的動態編輯網站, 使用者在 cmsimde 網際管理系統中所編輯的超文件內容存入套件 config 目錄中的 content.htm, 並且利用此超文件中的 H1~H3 標註作為分頁界線, 將 content.htm 分割為具有三個階層的頁面內容, 用來展示使用者所建立的最終 Github Pages 靜態網頁內容, 此網頁資料儲存在 cmsimde 套件中的 content 目錄, 並將靜態的 css 與 Javascript 儲存在 cmsimde 套件中的 static 目錄中. cmsimde 套件有關動態與靜態網站的標題、啟動網址與埠號設定位於 init.py 程式檔案中, 若將 init.py 中的啟動網址設為外部 IP, 則此網際內容管理系統的編輯網站, 可直接連外. Replit 靜態網站檢視 下載 main2.txt 與 static.txt, 其中包含 main2.py 與 static.py, 只要在 Shell 執行 python3 main2.py 就可以執行倉儲內的靜態網站檢視. 另一方面, 若要取消先前執行 python3 main2.py, 只需要在 Shell 頁面按下 ctrl + c, c 代表 cancle 也就是取消. 然後若要執行動態網站，可以在 Shell 執行 python3 main.py 或者使用 Replit 的 Run 按鍵. Replit 建立分組倉儲權限 由於 Replit 上的免費帳號僅允許與一個 Github 帳號對應, 因此若將分組網站 import 到 Replit, 必須自行在 /home/runner/.ssh 目錄下建立 id_rsa 與 config (id_rsa.pub 必須登錄到 Github 對應帳號), 其中的 config 內容為: Host github.com User git Hostname github.com 而 Host 的設定與 Windows putty 中的 session 名稱相同, 配合使用的 ssh 連線指令將會是: git clone --recurse-submodules git@github.com:mdewcm2024/分組倉儲名稱.git 當使用者完成 /home/runner/.ssh 目錄中的 id_rsa 與 config 建立後, Replit 會定期刪除免費用戶的 .ssh 目錄, 因此使用者必須將此兩個檔案存至隨身碟, 並在需要對分組倉儲改版時, 啟動分組倉儲的動態網站, 將隨身碟中的 id_rsa 與 config 檔案, upload 到分組倉儲的 downloads 目錄後, 再利用 ssh.py 的執行, 將 id_rsa 與 config 移動到 /home/runner/.ssh 目錄中. 也就是執行: python3 ssh.py ssh.py 程式內容如下: import os if not os.path.exists(\"/home/runner/.ssh\"): os.makedirs(\"/home/runner/.ssh\") os.system(\"mv ./downloads/id_rsa.txt /home/runner/.ssh/id_rsa\") os.system(\"mv ./downloads/config.txt /home/runner/.ssh/config\") os.system(\"chmod og-rwx /home/runner/.ssh/id_rsa\")","tags":"w4","url":"./w4.html"},{"title":"期末專案1","text":"塔羅牌 首先，確保您有一組塔羅牌的圖像文件，把它們儲存在一個名為「tarot_cards」的資料夾中。 pip install Pillow 接下來，可以使用以下Python代碼來創建一個簡單的塔羅牌應用程序 import os import random from PIL import Image 塔羅牌圖像文件夾 TAROT_FOLDER = \"tarot_cards\" 獲取所有塔羅牌圖像的文件名 tarot_cards = os.listdir(TAROT_FOLDER) 隨機選擇一張塔羅牌 selected_card = random.choice(tarot_cards) 打印所選塔羅牌的名稱 print(\"你的塔羅牌是：\" + selected_card) 顯示所選塔羅牌的圖像 image_path = os.path.join(TAROT_FOLDER, selected_card) image = Image.open(image_path) image.show() 這個代碼將隨機選擇一張塔羅牌，並顯示其圖像。並請確保您有一個名為\"tarot_cards\"的文件夾，其中包含塔羅牌圖像。 德州撲克 import random 定義撲克牌的花色和點數 suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace'] 初始化一副撲克牌 deck = [{'rank': rank, 'suit': suit} for rank in ranks for suit in suits] 洗牌 random.shuffle(deck) 發兩張牌給玩家和莊家 player_hand = [deck.pop(), deck.pop()] dealer_hand = [deck.pop(), deck.pop()] 顯示玩家的牌和一張莊家的牌 print(f'玩家的牌: {player_hand[0][\"rank\"]} of {player_hand[0][\"suit\"]} 和 {player_hand[1][\"rank\"]} of {player_hand[1][\"suit\"]}') print(f'莊家的牌: {dealer_hand[0][\"rank\"]} of {dealer_hand[0][\"suit\"]} 和 一張未知牌') 檢查是否有玩家或莊家已經有21點（Blackjack） def blackjack(hand): values = [card_value(card) for card in hand] return sum(values) == 21 計算牌的點數 def card_value(card): if card['rank'] in ['Jack', 'Queen', 'King']: return 10 elif card['rank'] == 'Ace': return 11 else: return int(card['rank']) 主遊戲迴圈 while True: # 檢查是否有玩家或莊家已經有21點 if blackjack(player_hand) or blackjack(dealer_hand): break # 玩家選擇要加牌還是停止 action = input('要加牌嗎？（加牌/停止）: ') if action.lower() == '加牌': player_hand.append(deck.pop()) print(f'你的牌: {\", \".join([card[\"rank\"] + \" of \" + card[\"suit\"] for card in player_hand])}') else: break 莊家加牌直到達到17點或更高 while sum([card_value(card) for card in dealer_hand]) < 17: dealer_hand.append(deck.pop()) 顯示最終結果 print(f'你的牌: {\", \".join([card[\"rank\"] + \" of \" + card[\"suit\"] for card in player_hand])}') print(f'你的點數: {sum([card_value(card) for card in player_hand])}') print(f'莊家的牌: {\", \".join([card[\"rank\"] + \" of \" + card[\"suit\"] for card in dealer_hand])}') print(f'莊家的點數: {sum([card_value(card) for card in dealer_hand])}') 判斷贏家 if sum([card_value(card) for card in player_hand]) > 21: print('你爆牌了，莊家贏了！') elif sum([card_value(card) for card in dealer_hand]) > 21: print('莊家爆牌了，你贏了！') elif sum([card_value(card) for card in player_hand]) > sum([card_value(card) for card in dealer_hand]): print('你贏了！') elif sum([card_value(card) for card in player_hand]) < sum([card_value(card) for card in dealer_hand]): print('莊家贏了！') else: print('平局！') 在執行上面的代碼後，你將開始一個簡單的德州撲克遊戲。遊戲的進行方式如下： 執行代碼：在你的 Python 開發環境中運行上面提供的代碼。這樣你就會看到一副洗好的撲克牌和玩家、莊家的初始牌。 玩家回合：遊戲將提示你進行選擇。你可以輸入\"加牌\"以繼續要求加牌，或者輸入\"停止\"以結束你的回合。 莊家回合：當你選擇\"停止\"或者當你的牌總和達到21點時，莊家將開始自己的回合，自動加牌直到達到17點或更高。 結算：遊戲將計算玩家和莊家的點數，並確定勝利者。結果將被輸出到屏幕上，以宣布遊戲的結果。 西洋棋 def create_board(): board = [ ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'] ] return board def print_board(board): def colored_piece(piece): if piece.islower(): return f\"\\033[94m{piece.upper()}\\033[0m\" # Dark blue for black pieces elif piece.isupper(): return f\"\\033[96m{piece}\\033[0m\" # Cyan for white pieces return piece print ( \" a b c d e f g h\" ) for i , row in enumerate ( board ): print ( 8 - i , \" \" . join ( colored_piece ( cell ) for cell in row )) def is_valid_move(board, start, end, player, en_passant): start_row, start_col = start end_row, end_col = end piece = board[start_row][start_col] if player == 'White' and piece.islower(): return False if player == 'Black' and piece.isupper(): return False if piece.lower() == 'p': return is_valid_move_pawn(board, start, end, en_passant) elif piece.lower() == 'r': return is_valid_move_rook(board, start, end) elif piece.lower() == 'n': return is_valid_move_knight(board, start, end) elif piece.lower() == 'b': return is_valid_move_bishop(board, start, end) elif piece.lower() == 'q': return is_valid_move_queen(board, start, end) elif piece.lower() == 'k': return is_valid_move_king(board, start, end) return False def is_valid_move_pawn(board, start, end, en_passant): start_row, start_col = start end_row, end_col = end piece = board[start_row][start_col] direction = - 1 if piece . isupper () else 1 start_row_base = 6 if piece . isupper () else 1 if board [ end_row ][ end_col ] == ' ' : if start_col == end_col : if end_row == start_row + direction : return True if start_row == start_row_base and end_row == start_row + 2 * direction and board [ start_row + direction ][ start_col ] == ' ' : return True if ( start_row , start_col ) == en_passant and end_row == start_row + direction and abs ( start_col - end_col ) == 1 : return True else : if abs ( start_col - end_col ) == 1 and end_row == start_row + direction : return True return False def is_valid_move_rook(board, start, end): start_row, start_col = start end_row, end_col = end if start_row != end_row and start_col != end_col: return False step_row = (end_row - start_row) // max(1, abs(end_row - start_row)) if start_row != end_row else 0 step_col = (end_col - start_col) // max(1, abs(end_col - start_col)) if start_col != end_col else 0 for i in range(1, max(abs(end_row - start_row), abs(end_col - start_col))): if board[start_row + i * step_row][start_col + i * step_col] != ' ': return False return True def is_valid_move_knight(board, start, end): start_row, start_col = start end_row, end_col = end return (abs(start_row - end_row), abs(start_col - end_col)) in [(1, 2), (2, 1)] def is_valid_move_bishop(board, start, end): start_row, start_col = start end_row, end_col = end if abs(start_row - end_row) != abs(start_col - end_col): return False step_row = (end_row - start_row) // abs(end_row - start_row) step_col = (end_col - start_col) // abs(end_col - start_col) for i in range(1, abs(end_row - start_row)): if board[start_row + i * step_row][start_col + i * step_col] != ' ': return False return True def is_valid_move_queen(board, start, end): return is_valid_move_rook(board, start, end) or is_valid_move_bishop(board, start, end) def is_valid_move_king(board, start, end): start_row, start_col = start end_row, end_col = end return max(abs(start_row - end_row), abs(start_col - end_col)) == 1 def move_piece(board, start, end, player, en_passant): if not is_valid_move(board, start, end, player, en_passant): print(\"无效的移动!\") return en_passant start_row, start_col = start end_row, end_col = end # 处理过路兵 if board [ start_row ][ start_col ] . lower () == 'p' and ( start_row , start_col ) == en_passant and abs ( start_col - end_col ) == 1 : if player == 'White' : board [ end_row + 1 ][ end_col ] = ' ' else : board [ end_row - 1 ][ end_col ] = ' ' board [ end_row ][ end_col ] = board [ start_row ][ start_col ] board [ start_row ][ start_col ] = ' ' # 处理升变 if board [ end_row ][ end_col ] . lower () == 'p' : if ( player == 'White' and end_row == 0 ) or ( player == 'Black' and end_row == 7 ) : while True : promotion = input ( \"选择升变的棋子 (Q/R/B/N): \" ). upper () if promotion in 'QRBN' : board [ end_row ][ end_col ] = promotion if player == 'White' else promotion . lower () break # 返回新的过路兵位置 if board [ end_row ][ end_col ] . lower () == 'p' and abs ( start_row - end_row ) == 2 : return ( end_row , end_col ) return None def parse_position(position): if len(position) != 2: raise ValueError(\"位置格式不正确，请输入类似 'e2' 的格式。\") col, row = position if col not in \"abcdefgh\" or row not in \"12345678\": raise ValueError(\"位置格式不正确，请输入类似 'e2' 的格式。\") col = ord(col) - ord(\"a\") row = 8 - int(row) return (row, col) def game_instructions(): print(\"欢迎来到西洋棋游戏!\") print(\"游戏规则说明:\") print(\"1. 两位玩家轮流进行游戏，白方先行。\") print(\"2. 使用棋盘上的位置来移动棋子，例如 'e2' 移动到 'e4'。\") print(\"3. 黑色棋子为深蓝色，白色棋子为水蓝色。\") print(\"4. 特殊规则：兵的升变、过路兵、易位、将军、将死等。\") print(\"请享受游戏!\\n\") def play_chess(): game_instructions() board = create_board() current_player = \"White\" en_passant = None while True: print_board(board) print(f\"{current_player} 的回合\") while True: try: start = input(\"输入起始位置 (例如 e2): \") start_pos = parse_position(start) break except ValueError as e: print(e) while True: try: end = input(\"输入结束位置 (例如 e4): \") end_pos = parse_position(end) break except ValueError as e: print(e) en_passant = move_piece(board, start_pos, end_pos, current_player, en_passant) current_player = \"Black\" if current_player == \"White\" else \"White\" if input(\"是否结束游戏？ (y/n): \").lower() == \"y\": break if name == \" main \": play_chess() 這是一款文字版的西洋棋遊戲，具有以下特點： 雙人遊戲：兩位玩家輪流操作，白方先行。 文字介面：玩家輸入棋子位置來移動棋子。 棋盤顯示：棋盤以表格形式顯示，黑方棋子為深藍色，白方棋子為水藍色。 特殊規則：包括兵的升變、過路兵、易位、將軍和將死等規則。 遊戲說明：玩家輸入起始和結束位置來移動棋子，例如 \"e2 e4\"。 系統檢查移動是否合法，合法則更新棋盤，不合法則提示重新輸入。 特殊移動如兵的升變和易位會自動處理。 隨時輸入 \"y\" 結束遊戲。 五子棋 def initialize_board(size=15): return [[' ' for _ in range(size)] for _ in range(size)] def colored_piece(piece): if piece == 'X': return f\"\\033[91m{piece}\\033[0m\" # Red elif piece == 'O': return f\"\\033[92m{piece}\\033[0m\" # Green return piece def print_board(board): size = len(board) # Print the top column numbers print(\" \" + \" \".join(f\"{i+1:2}\" for i in range(size))) print(\" +\" + \"---+\" * size) for idx, row in enumerate(board): print(f\"{idx+1:2} | \" + \" | \".join(colored_piece(cell) for cell in row) + \" |\") print(\" +\" + \"---+\" * size) def check_winner(board, player): size = len(board) # Check horizontal, vertical, and diagonal lines for row in range(size): for col in range(size): if board[row][col] == player: # Check horizontal if col + 4 < size and all(board[row][col+i] == player for i in range(5)): return True # Check vertical if row + 4 < size and all(board[row+i][col] == player for i in range(5)): return True # Check diagonal (down-right) if row + 4 < size and col + 4 < size and all(board[row+i][col+i] == player for i in range(5)): return True # Check diagonal (down-left) if row + 4 < size and col - 4 >= 0 and all(board[row+i][col-i] == player for i in range(5)): return True return False def play_game(): board = initialize_board() print(\"歡迎來到五子棋遊戲！\") print(\"玩家1: 黑子 (X) \\033[91m紅色\\033[0m\") print(\"玩家2: 白子 (O) \\033[92m綠色\\033[0m\") current_player = 'X' # X starts the game, representing black stones while True: print_board(board) print(f\"玩家 {current_player} 的回合\") try: row = int(input(\"請輸入行 (1-15): \")) - 1 col = int(input(\"請輸入列 (1-15): \")) - 1 if 0 <= row < len(board) and 0 <= col < len(board[0]) and board[row][col] == ' ': board[row][col] = current_player if check_winner(board, current_player): print_board(board) print(f\"玩家 {current_player} 獲勝！\") break current_player = 'O' if current_player == 'X' else 'X' else: print(\"無效的移動，請重試。\") except ValueError: print(\"請輸入有效的數字。\") if name == \" main \": play_game() 這是一款文字版的五子棋遊戲，旨在提供玩家一個簡單且有趣的方式來享受五子棋的樂趣。以下是這款五子棋遊戲的主要特點和玩法說明： 遊戲特點 雙人遊戲：兩位玩家輪流下棋，輪流放置黑子（X）和白子（O）。 文字介面：玩家需要輸入棋子的位置來進行落子。 棋盤顯示：棋盤以表格形式顯示，每個位置用數字標示，方便玩家輸入。 簡單易用：遊戲規則簡單，適合所有年齡段的玩家。 遊戲玩法說明 遊戲開始：啟動遊戲後，系統會顯示初始空棋盤，並提示黑方玩家進行落子。 輸入落子位置：玩家需要輸入棋子的行和列，例如在第4行第5列落子，輸入格式為 \"4 5\"。 檢查落子：系統會檢查輸入的位置是否合法，包括是否在棋盤範圍內，該位置是否已被佔用等。 更新棋盤：如果落子合法，系統將更新棋盤並顯示新狀態；如果不合法，系統會提示玩家重新輸入。 勝利條件：系統自動檢查是否有五個連續相同顏色的棋子（橫、縱或斜），若有，則該玩家獲勝。 遊戲連結： https://github.com/otakuyoyo/gomoku/blob/main/gomoku.html","tags":"期末專案1","url":"./期末專案1.html"},{"title":"2024 Spring 課程","text":"2024 Spring 網際內容管理與協同產品設計實習課程教學導引. 內容管理系統 使用者可以自行利用 cmsimde_site 倉儲作為 Template, 建立自己的網站內容管理系統. 引用網站網址連結的方法: cmsimde_site - 在文章中多次引用同一個網站連結時, 可以使用此種方法. https://github.com/mdecycu/cmsimde_site - 假如想要快速將網址套用 html 網站連結, 可以使用此種方法. cmsimde_site - 也可以使用 Markdown 的標準網站連結使用格式. # 引用 Python 程式的方法 for i in range(10): print(i, \"列出字串\") 也可以直接在 .md 檔案中使用 html 標註, 或加入 Javascript 或 Brython 程式碼. 從 1 累加到 100: 1 add to 100 將 iterable 與 iterator 相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. Filename: .py Run Output 清除輸出區 清除繪圖區 Reload 從 1 累加到 100 part2: 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block Filename: .py Run Output 清除輸出區 清除繪圖區 Reload","tags":"w1","url":"./2024-Spring-w1-blog-tutorial.html"}]}